<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Claude Terminal</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background: #1e1e2e;
        }
        #terminal {
            height: 100%;
            width: 100%;
        }
        #scroll-indicator {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(137, 180, 250, 0.9);
            color: #1e1e2e;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
            display: none;
            z-index: 1000;
            cursor: pointer;
        }
        #scroll-indicator.visible {
            display: block;
        }
        .xterm-viewport::-webkit-scrollbar {
            width: 8px;
        }
        .xterm-viewport::-webkit-scrollbar-track {
            background: #1e1e2e;
        }
        .xterm-viewport::-webkit-scrollbar-thumb {
            background: #45475a;
            border-radius: 4px;
        }
    </style>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css">
</head>
<body>
    <div id="terminal"></div>
    <div id="scroll-indicator">â†“ New output (PgDn)</div>
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-web-links@0.9.0/lib/xterm-addon-web-links.min.js"></script>
    <script>
        (function() {
            const terminal = new Terminal({
                fontSize: 14,
                fontFamily: 'Menlo, Monaco, "Courier New", monospace',
                cursorBlink: true,
                cursorStyle: 'bar',
                scrollback: 50000,
                scrollOnUserInput: false,
                theme: {
                    background: '#1e1e2e',
                    foreground: '#cdd6f4',
                    cursor: '#f5e0dc',
                    cursorAccent: '#1e1e2e',
                    selection: '#45475a',
                    black: '#45475a',
                    red: '#f38ba8',
                    green: '#a6e3a1',
                    yellow: '#f9e2af',
                    blue: '#89b4fa',
                    magenta: '#f5c2e7',
                    cyan: '#94e2d5',
                    white: '#bac2de',
                    brightBlack: '#585b70',
                    brightRed: '#f38ba8',
                    brightGreen: '#a6e3a1',
                    brightYellow: '#f9e2af',
                    brightBlue: '#89b4fa',
                    brightMagenta: '#f5c2e7',
                    brightCyan: '#94e2d5',
                    brightWhite: '#a6adc8'
                }
            });

            const fitAddon = new FitAddon.FitAddon();
            const webLinksAddon = new WebLinksAddon.WebLinksAddon();
            const indicator = document.getElementById('scroll-indicator');

            terminal.loadAddon(fitAddon);
            terminal.loadAddon(webLinksAddon);
            terminal.open(document.getElementById('terminal'));
            fitAddon.fit();

            // Scroll tracking
            let hasNewOutput = false;

            function isAtBottom() {
                const vp = document.querySelector('.xterm-viewport');
                if (!vp) return true;
                return vp.scrollTop + vp.clientHeight >= vp.scrollHeight - 50;
            }

            function updateIndicator() {
                if (hasNewOutput && !isAtBottom()) {
                    indicator.classList.add('visible');
                } else {
                    indicator.classList.remove('visible');
                    hasNewOutput = false;
                }
            }

            const viewport = document.querySelector('.xterm-viewport');
            if (viewport) viewport.addEventListener('scroll', updateIndicator);

            // === TTYD WebSocket Protocol ===
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = protocol + '//' + location.host + '/ws';
            const socket = new WebSocket(wsUrl, ['tty']);

            const textEncoder = new TextEncoder();
            const textDecoder = new TextDecoder();

            // ttyd message types
            const MSG_INPUT = '0';
            const MSG_RESIZE = '1';
            const MSG_OUTPUT = '0';
            const MSG_SET_WINDOW_TITLE = '1';
            const MSG_SET_PREFS = '2';

            socket.binaryType = 'arraybuffer';

            socket.onopen = function() {
                console.log('Connected to ttyd');
            };

            socket.onmessage = function(event) {
                const data = new Uint8Array(event.data);
                const cmd = String.fromCharCode(data[0]);
                const payload = data.slice(1);

                switch(cmd) {
                    case MSG_OUTPUT:
                        terminal.write(payload);
                        if (!isAtBottom()) {
                            hasNewOutput = true;
                            updateIndicator();
                        }
                        break;
                    case MSG_SET_WINDOW_TITLE:
                        document.title = textDecoder.decode(payload);
                        break;
                    case MSG_SET_PREFS:
                        // Ignore server preferences, we use our own
                        break;
                }
            };

            socket.onclose = function() {
                terminal.write('\r\n\x1b[31mConnection closed. Refresh to reconnect.\x1b[0m\r\n');
            };

            socket.onerror = function(err) {
                console.error('WebSocket error:', err);
            };

            // Send input to ttyd
            terminal.onData(function(data) {
                if (socket.readyState === WebSocket.OPEN) {
                    const msg = new Uint8Array(data.length + 1);
                    msg[0] = MSG_INPUT.charCodeAt(0);
                    for (let i = 0; i < data.length; i++) {
                        msg[i + 1] = data.charCodeAt(i);
                    }
                    socket.send(msg);
                }
            });

            // Send resize to ttyd
            function sendResize() {
                if (socket.readyState === WebSocket.OPEN) {
                    const dims = fitAddon.proposeDimensions();
                    if (dims) {
                        const msg = MSG_RESIZE + JSON.stringify({cols: dims.cols, rows: dims.rows});
                        socket.send(textEncoder.encode(msg));
                    }
                }
            }

            window.addEventListener('resize', function() {
                fitAddon.fit();
                sendResize();
            });

            // Initial resize after connection
            socket.addEventListener('open', function() {
                setTimeout(function() {
                    fitAddon.fit();
                    sendResize();
                }, 100);
            });

            // Keyboard navigation
            document.addEventListener('keydown', function(e) {
                const scrollAmount = terminal.rows - 2;

                if (e.key === 'PageUp') {
                    e.preventDefault();
                    terminal.scrollLines(-scrollAmount);
                }
                else if (e.key === 'PageDown') {
                    e.preventDefault();
                    terminal.scrollLines(scrollAmount);
                    updateIndicator();
                }
                else if (e.key === 'End' && e.ctrlKey) {
                    e.preventDefault();
                    terminal.scrollToBottom();
                    hasNewOutput = false;
                    updateIndicator();
                }
                else if (e.key === 'Home' && e.ctrlKey) {
                    e.preventDefault();
                    terminal.scrollToTop();
                }
                else if (e.key === 'ArrowUp' && e.shiftKey) {
                    e.preventDefault();
                    terminal.scrollLines(-1);
                }
                else if (e.key === 'ArrowDown' && e.shiftKey) {
                    e.preventDefault();
                    terminal.scrollLines(1);
                    updateIndicator();
                }
            });

            // Click indicator to scroll down
            indicator.addEventListener('click', function() {
                terminal.scrollToBottom();
                hasNewOutput = false;
                updateIndicator();
            });

            // Initial fit
            setTimeout(() => fitAddon.fit(), 100);
        })();
    </script>
</body>
</html>
